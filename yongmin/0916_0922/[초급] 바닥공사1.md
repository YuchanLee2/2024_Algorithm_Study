# 정렬된 많은 원소 사이에서 특정 원소 풀이 방법

### Python
방법

가로 길이는 N으로 가변이고, 세로 길이는 2로 고정이다.  
따라서 가로길이 N만 생각한다면, 1 x 2 타일로는 언제든지 바닥을 채울 수 있고, 2 x 1 타일로는 무조건 빈 칸이 남는다.  

즉, 우리가 생각해야 할 건 1 x 2 타일이 몇 개 들어가는지이고 그것만 정한다면 2 x 1 타일은 자연스레 결정된다. (반대로도 된다.)  

먼저 3 x 2인 바닥을 생각해보자.  
(1 x 2 타일을 A, 2 x 1 타일을 B라고 하자.)  
1. A - 3개인 경우의 수 : 1 : 3C3
2. A - 1개인 경우 : 2 : 2C1
이렇게 총 3가지이다.  

4 x 2인 바닥은  
1. A - 4개인 경우의 수 : 1 : 4C4
2. A - 2개인 경우의 수 : 3 : 3C2
3. A - 0개인 경우의 수 : 1 : 2C0
이렇게 총 5가지이다.  

마지막으로 5 x 2인 바닥은  
1. A - 5개인 경우의 수 : 1 : 5C5
2. A - 3개인 경우의 수 : 4 : 4C3
3. A - 1개인 경우의 수 : 3 : 3C1
이렇게 총 8가지 이다.

이 때 A 타일의 개수는 2씩 (2 x 1 타일이기 때문) 감소한다.  
그렇다면 문제는 가로길이 1칸씩 N개들 중 A 타일이 들어갈 타일을 고르는 조합(Combination) 문제와 같아진다.  
다만 2 x 1은 가로길이 1칸씩 2개가 무조건 같이 붙어있어야 하기 때문에  
5 x 2 바닥의 경우 2번째 경우의 수는 가로길이 1칸씩 4개들 중 3개를 고르는 조합 문제가 되는 것이다.  

즉 패턴은 다음과 같다.  

A 타일의 개수는 N - 2 * i for i in range(N),  
그리고 loop가 돌면서 N개중 R개를 선택해야하는데, R의 개수는 1씩 줄어든다.

```python
n = length
for i in range(length, -1, -2):
    result += math.comb(n, i) # 방법의 가짓수
    n -= 1
```

### JAVA
방법은 파이썬과 동일하다.  
그러나 comb함수를 찾을 수 없어서 comb를 직접 만들기로 했다.  
```java
public static int comb(int n, int k) {
        // n! / k! (n-k)!
        int n_f = 1;
        int k_f = 1;
        int nk_f = 1;
        
        for (int i = n; i > 0; i--){
            n_f = n_f * i;
        }
        
        for (int i = k; i > 0; i--){
            k_f = k_f * i;
        }
        
        for (int i = n-k; i > 0; i--){
            nk_f = nk_f * i;
        }
        
        return n_f / (k_f * nk_f);
    }
```
이런 식으로 만들었다.  
Main 바깥에서 클래스로 Combination을 만들면 오류가 나더라;;  
그래서 public static int써서 해줬다.  
